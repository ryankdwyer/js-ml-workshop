{"version":3,"sources":["kmeans_specs.js"],"names":[],"mappings":"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","file":"kmeans_specs-compiled.js","sourcesContent":["\nvar KMeans = require('./kmeans');\nvar expect = require('chai').expect;\nvar randomPoints = require('../lib/rand');\nvar mnist = require('../lib/mnist_reader');\nvar writer = require('../lib/writer');\n\n/*The function 'distance' is useful for tests, to see if values are converging on \n  the correct location for the centroid.\n\n  Yes, you can use it for the '_distance' function below if you wish.\n*/\nvar distance = function(one,two){\n\treturn Math.sqrt(one.reduce(function(old, _, index){\n\t\t\treturn old + Math.pow( one[index] - two[index], 2)\n\t\t}, 0)\n\t);\n}\n\n\ndescribe('Testing required k-means functionality.', function(){\n\n\tit('is a function', function(){\n\t\texpect(typeof KMeans).to.equal('function');\n\t});\n\n\tit('should have all the requisite functions', function(){\n\t\tvar km = new KMeans();\n\t\t//The array 'points' is the set of vectors with which the algorithm is to be trained.\n\t\texpect(km.points).to.be.empty;\n\t\t//When all the clusters move less than this per training period, k-means stops adjusting\t\t\t\t\t\t\t\n\t\texpect(km.minClusterMove !== undefined).to.be.true;\n\t\texpect(typeof km.train).to.equal('function');\t\t\t//Adds vectors to points\n\t\texpect(typeof km.clusters).to.equal('function');\t\t//Returns a list of centroids\n\t});\n\n\tit(' adds points to the list of points that it trains with, when train is called', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tknn.train(typeA);\n\t\t\texpect(knn.points.length).to.equal(100);\n\t});\n\n\t/* As in the prior exercise, the following are functions which might make\n\t   the task of writing the function 'clusters' much easier.  But it is\n\t   not necessary that you use them in any way.  I suggest that you \n\t   look through them in any event, though, to get an idea of the kinds of\n\t   functions you will need to write.\n\t */\n\tdescribe('Optional helper functions to help build the k-means algorithm', function(){\n\n\t\t/* The function '_distance' takes as input two vectors of any length,\n\t\t   and returns the Euclidean norm of the difference between them\n\t\t   That is, it takes two vectors of length n and returns the Euclidean distance\n\t\t   between the positions that they indicate in n-dimensional space.\n\t\t*/\n\t\tit('has _distance, which determines the Euclidean norm / distance between two vectors', function(){\n\t\t\tvar km = new KMeans();\n\t\t\texpect(typeof km._distance).to.equal('function');\n\t\t\texpect(km._distance([0,0],[3,4])).to.equal(5);\n\t\t\texpect(km._distance([20,0],[21,0])).to.equal(1);\n\t\t\texpect(km._distance([20,20],[20,20])).to.equal(0);\n\t\t});\n\n\t\t/* The function '_max' takes as input an array and a function.\n\t\t   The function should return a number when any element of the\n\t\t   array is fed into it.  '_max' itself will return the value\n\t\t   from the array which is greatest when fed into the function\n\t\t   passed to max.\n\n\t\t   Example: knn._max(['a','bb','c','aaa','cc'], function(n){return n.length; }) will return 'aaa'\n\n\t\t   This is actually pretty much the same as the lodash max,\n\t\t   so if you want to you can just use that.\n\t\t */\n\t\tit('has _max, which takes an array and a function and returns the element from the array for which what the function returns is highest', function(){\n\t\t\tvar km = new KMeans();\n\t\t\texpect(typeof km._max).to.equal('function');\n\t\t\texpect(km._max([0,1,2,3,4,5,6], function(n){return n;})).to.equal(6);\n\t\t\texpect(km._max([0,1,2,3,4,5,6], function(n){return -n;})).to.equal(0);\n\t\t\texpect(km._max(['a','sas','asdasd','ssd'], function(n){return n.length;})).to.equal('asdasd');\n\t\t\t//With index\n\t\t\texpect(km._max([0,1,2,3,4,5,6], function(n, index){return -index;})).to.equal(0);\n\t\t\texpect(km._max([10,1,2,3,4,5,6], function(n, index){return -index;})).to.equal(10);\n\t\t\texpect(km._max([7,1,2,6,4,3,2], function(n, index){return index+n;})).to.equal(6);\n\t\t});\n\n\t\t/* The function '_clusterEvaluator' takes as input two things--an array of\n\t\t   centroids (vectors) and an array of training points (vectors).\n\n\t\t   It then evaluates how good the clustering indicated by the centroids\n\t\t   is, by returning the sum of the squares of the distances from each element in the training points\n\t\t   to the closest of the centroids; that is, it returns the sum of the squares of the\n\t\t   centroid to training-point distances.  A list of centroids which has a\n\t\t   smaller such sum is better than a list of centroids\n\t\t   which has a larger such sum.  This is because the goal of k-means is to, after all,\n\t\t   minimize this distance; the standard algorithm which we implement is merely\n\t\t   a way of trying to do so.\n\n\t\t   Note that you would NOT want to use this function in a straightforward way in\n\t\t   '_max' above, because the LOWER the value returned from this the \n\t\t   better the clustering, while '_max' returns the HIGHEST value.  But you could use a function\n\t\t   that calls it.\n\n\t\t   Might want to use '_distance'.\n\t\t*/\n\t\tit('has _clusterEvaluator, which scores clusters according to the average distances from points to centroids in each', function(){\n\t\t\tvar km = new KMeans();\n\t\t\texpect(typeof km._clusterEvaluator).to.equal('function');\n\t\t\texpect(km._clusterEvaluator( [[0,0],[100,100]],[[1,0],[0,1],[101,100],[100,101]] ) ).to.equal(4);\n\t\t\texpect(km._clusterEvaluator( [[0,0],[100,100]],[[2,0],[0,2],[102,100],[100,102]] ) ).to.equal(16);\n\t\t\texpect(km._clusterEvaluator( [[0,0]],[[3,0],[0,3],[0,-3],[-3,0]] ) ).to.equal(36);\n\t\t});\n\n\t\t/* The function '_averageLocation' takes an array of vectors and returns the mean\n\t\t   location of the vectors in the array.\n\n\t\t   This could obviously be useful when determining the center of a group of vectors.\n\t\t */\n\t\tit('has _averageLocation, which takes an array of vectors and returns the mean location', function(){\n\t\t\tvar km = new KMeans();\n\t\t\texpect(typeof km._averageLocation).to.equal('function');\n\t\t\texpect(km._averageLocation([[1,1],[1,1],[4,4]])).to.eql([2,2])\n\t\t\t//expect(km._averageLocation([[1,1],[1,1],[2,2],[2,2]])).to.eql([1.5,1.5])\n\t\t\t//expect(km._averageLocation([[1,1],[2,2],[3,3]])).to.eql([2,2])\n\t\t\t//expect(km._averageLocation([[1,1],[1,1]])).to.eql([1,1])\n\t\t\t//expect(km._averageLocation([[1,2],[1,2],[2,3],[3,4],[3,4]])).to.eql([2,3])\n\t\t\t//expect(km._averageLocation([[1,10],[1,10],[2,10],[3,10],[3,10]])).to.eql([2,10])\n\t\t});\n\n\t\t/* The following function, '_shiftCentroids', is rather the heart of k-means.  \n\n\t\t   It takes as input (1) an array of centroids, and an (1) array of all the training data.\n\t\t   Each of the elements of these are vectors--that is, simply arrays of numbers.\n\n\t\t   It outputs a new list of shifted centroids.  This list is produced by\n\t\t   dividing the training data into groups, each group consisting of the data points\n\t\t   closer to one centroid than to any other centroid, and then shifting that centroid\n\t\t   to the mean location of the groups.\n\n\t\t   This should probably be the longest function that you write.\n\t\t   I got it down to 12 lines; see if you can do better.\n\n\t\t   May want to use '_distance', '_averageLocation.''\n\t\t  */\n\t\tit('has _shiftCentroids, which takes centroids, and all the points and shifts centroids a step', function(){\n\t\t\tvar km = new KMeans();\n\t\t\texpect(typeof km._shiftCentroids).to.equal('function');\n\t\t\t//Shouldn't shift anything at all.\n\t\t\texpect(km._shiftCentroids([[0,0],[100,100]],[[1,0],[0,1],[-1,0],[0,-1],[100,101],[101,100],[99,100],[100,99]])).to.eql([[0,0],[100,100]]);\n\t\t\t//Should shift one of the centroids, but not the other one.\n\t\t\texpect(km._shiftCentroids([[0,0],[100,100]],[[1,0],[0,1],[-1,0],[0,-1],[200,201],[201,200],[199,200],[200,199]])).to.eql([[0,0],[200,200]]);\n\t\t\t//Should shift both of the centroids.\n\t\t\texpect(km._shiftCentroids([[0,1],[101,100]],[[4,0],[0,4],[-4,0],[0,-4],[200,202],[202,200],[198,200],[200,198]])).to.eql([[0,0],[200,200]]);\n\t\t});\n\n\t\t/* The function '_haveShifted' takes two lists of vectors.\n\t\t   The n-th elements of each of which are taken to correspond to before\n\t\t   and after states for centroids shifted through the above.\n\n\t\t   If any of them have shifted more than a tiny amount, it returns true.\n\n\t\t   Might want to use '_distance.''\n\t\t */\n\t\tit('has _haveShifted, which takes two arrays of centroids, and determines if they have shifted', function(){\n\t\t\tvar km = new KMeans();\n\t\t\texpect(typeof km._shiftCentroids).to.equal('function');\n\t\t\texpect(km._haveShifted([[1,1,1]],[[1,1,1]])).to.equal(false)\n\t\t\texpect(km._haveShifted([[1,1,1],[2,2,2]],[[1,1,1],[2,2,2]])).to.equal(false)\n\t\t\texpect(km._haveShifted([[1,1,1],[2,2,2]],[[1,1,1],[2,2,2.4]])).to.equal(true)\n\t\t\texpect(km._haveShifted([[1,1,1.1],[2,2,2]],[[1,1,1],[2,2,2]])).to.equal(true)\n\t\t\texpect(km._haveShifted([[1,1.01,1],[2,2,2]],[[1,1,1],[2,2,2]])).to.equal(true)\n\t\t\texpect(km._haveShifted([[1,1],[2,2]],[[1,1],[2,2]])).to.equal(false)\n\t\t\texpect(km._haveShifted([[1],[2]],[[1],[2]])).to.equal(false)\n\t\t\texpect(km._haveShifted([[1],[2]],[[1],[2.1]])).to.equal(true)\n\t\t});\n\n\t\t/* If you follow the path lined out here, .cluster will return the best cluster\n\t\t   of several iterations of k-means.\n\n\t\t   This function, '_clusters', simply returns a single group of clusters produced by one \n\t\t   complete iteration of k-means.  That is, it loops through Lloyd's algorithm until\n\t\t   the centroids have ceased moving or ceased moving by more than a certain amount.\n\n\t\t   This will probably use '_shiftCentroids' and '_haveShifted'.  You might find it useful to\n\t\t   write an ancillary function that helps you choose random initial locations from the\n\t\t   vectors passed in; I did this in a somewhat complex functional map, and there are\n\t\t   probably more straightforward ways to do it.\n\n\t\t   This is probably the second most difficult function to write, after _shiftCentroids.\n\n\t\t   It takes as input (1) the number of clusters whose centers it is trying to locate as well as\n\t\t   (2) the data it is trying to find clusters on.\n\t\t */\n\t\tit('has _clusters, which returns a single cluster, but without trying multiple iterations of k-means', function(){\n\t\t\tvar km = new KMeans();\n\t\t\texpect(typeof km._clusters).to.equal('function');\n\t\t\t//Returns the right number.\n\t\t\texpect(km._clusters(1,[[1,1],[0,0]]).length).to.equal(1);\n\t\t\texpect(km._clusters(2,[[1,1],[0,0]]).length).to.equal(2);\n\t\t\texpect(km._clusters(3,[[1,1],[0,0],[2,2]]).length).to.equal(3);\n\t\t\t//Returns in a sensical location\n\t\t\tvar temp = km._clusters(2,[[1,0],[0,0]]);\n\t\t\texpect( distance([0,0], temp[0]) == 1 || distance([0,0], temp[0]) == 0 ).to.equal(true)\n\t\t\texpect( distance([0,0], temp[1]) == 1 || distance([0,0], temp[1]) == 0 ).to.equal(true)\n\t\t});\n\n\t\t/* The function '_manyClusters' invokes '_clusters' several times, and each time\n\t\t   adds the results of '_clusters' to an array it returns\n\n\t\t   It takes as input (1) the number of times to invoke '_clusters' and (2) the\n\t\t   number of clusters to tell '_clusters' to locate.\n\n\t\t   (It pulls the vectors that it will be passing to _clusters'\n\t\t   second argument from this.points.)\n\t\t*/\n\t\tit('has _manyClusters, which is returns an array of clusters', function(){\n\t\t\tvar km = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tkm.train(typeA);\n\t\t\texpect(typeof km._manyClusters).to.equal('function');\n\t\t\texpect(km._manyClusters(10,2).length).to.equal(10);\n\t\t\texpect(km._manyClusters(10,2)[0].length).to.equal(2);\n\t\t});\n\n\t});\n\n\t/*Alright, all of that prep work done, now for the rest of the problem.*/\n\tdescribe('The algorithm can find locations successfully with the function clusters.', function(){\n\n\t\t/* The function .clusters takes a number.  It returns an array of vectors,\n\t\t   each vector being the location of a centroid determined by the function.\n\n\t\t   To make this function accurate, you'll probably need to iterate through\n\t\t   the basic k-means algorithm several times and return the best result.\n\n\t\t   ------\n\n\t\t   If you slogged through the entirety of the above preperator work, here's\n\t\t   a bonus.  This is the entire amount of code needed for '.clusters',\n\t\t   assuming you pass all the above tests (and assuming that you do so in a\n\t\t   stable fashion).\n\n\t\t   KMeans.prototype.clusters = function(clusterNum){\n\t\t\t\tvar self = this;\n\t\t\t\treturn this._max( this._manyClusters( this.clusterAttempts, clusterNum ) , function(cluster){\n\t\t\t\t\treturn -self._clusterEvaluator(cluster, self.points);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tTada!  That's it.\n\t\t*/\n\n\t\tit(' can determine the location of two centroids with .clusters, being told there are two', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tvar typeB = randomPoints(100,[1,1],[50,0]);\n\t\t\tvar both = typeB.concat(typeA);\n\t\t\tknn.train(both);\n\t\t\tvar res = knn.clusters(2);\n\t\t\texpect(res.length).to.equal(2);\n\t\t\texpect( (distance(res[0], [0.5,0.5]) < .1) || (distance(res[0], [50.5,0.5]) < .1) ).to.be.true;\n\t\t\texpect( (distance(res[1], [0.5,0.5]) < .1) || (distance(res[1], [50.5,0.5]) < .1) ).to.be.true;\n\t\t});\n\n\t\tit(' can determine the location of three centroids, being told there are three', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tvar typeB = randomPoints(100,[1,1],[30,0]);\n\t\t\tvar typeC = randomPoints(100,[1,1],[15,20]);\n\t\t\tvar all = typeA.concat(typeB.concat(typeC));\n\t\t\tknn.train(all);\n\t\t\tvar res = knn.clusters(3);\n\t\t\texpect(res.length).to.equal(3);\n\t\t\texpect( (distance(res[0], [0.5,0.5]) < .1) || (distance(res[0], [30.5,0.5]) < .1) || (distance(res[0], [15.5,20.5]) < .1)).to.be.true;\n\t\t\texpect( (distance(res[1], [0.5,0.5]) < .1) || (distance(res[1], [30.5,0.5]) < .1) || (distance(res[1], [15.5,20.5]) < .1)).to.be.true;\n\t\t\texpect( (distance(res[2], [0.5,0.5]) < .1) || (distance(res[2], [30.5,0.5]) < .1) || (distance(res[2], [15.5,20.5]) < .1)).to.be.true;\n\t\t});\n\n\t\tit(' can determine the location of three closer centroids, being told there are three', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tvar typeB = randomPoints(100,[1,1],[3,0]);\n\t\t\tvar typeC = randomPoints(100,[1,1],[1.5,2]);\n\t\t\tvar all = typeA.concat(typeB.concat(typeC));\n\t\t\tknn.train(all);\n\t\t\tvar res = knn.clusters(3);\n\t\t\texpect(res.length).to.equal(3);\n\t\t\texpect( (distance(res[0], [0.5,0.5]) < .1) || (distance(res[0], [3.5,0.5]) < .1) || (distance(res[0], [2,2.5]) < .1)).to.be.true;\n\t\t\texpect( (distance(res[1], [0.5,0.5]) < .1) || (distance(res[1], [3.5,0.5]) < .1) || (distance(res[1], [2,2.5]) < .1)).to.be.true;\n\t\t\texpect( (distance(res[2], [0.5,0.5]) < .1) || (distance(res[2], [3.5,0.5]) < .1) || (distance(res[2], [2,2.5]) < .1)).to.be.true;\n\t\t});\n\t});\n\n\t/* So, \"successfully\" is in quotation marks because there is no very rigorous idea of what success is.\n\t   The below tests will always pass when run, assuming you give them sufficient\n\t   time to finish.  They produce, however, some data in the folder in which this runs,\n\t   which will display grouped members of the clusters produced by the algorithm.\n\n\t   In this context, \"success\" means that the each of the clusters seem to have something in common with \n\t   each other.  It would be a little too much to hope for, with this rather crude algorithm, to have\n\t   all the members of each cluster be the same character.\n\n\t   Consider how well the algorith sorts the characters 1 and 0 into separate groups,\n\t   as well as the characters 5 and 9, and the characters 4, 6, and 8.  Some \n\t   of these groupings are \"better\" than others.  Which and why?\n\t*/\n\txdescribe('The algorithm finds centroids for the MNIST data \"successfully\"', function(){\n\n\t\tit('finds centroids data consisting of the characters 1 and 0', function(done){\n\t\t\tthis.timeout(10000);\n\t\t\tvar knn = new KMeans();\n\t\t\tvar someElements = mnist.zeroAndOne().map(function(n){return n[0]}).slice(0,100);\n\t\t\tknn.train(someElements)\n\t\t\tconsole.log('Finding clusters for images consisting of 1 and 0')\n\t\t\tvar res = knn.clusters(2);\n\t\t\t//console.log('Writing images...');\n\t\t\tdone();\n\t\t\t//writer.exportGrouped(res, someElements, done, \"zeroOne\")\n\t\t});\n\n\t\tit('finds centroids for data consisting of the characters 5 and 9', function(done){\n\t\t\tthis.timeout(10000);\n\t\t\tvar knn = new KMeans();\n\t\t\tvar someElements = mnist.fiveAndNine().map(function(n){return n[0]}).slice(0,120);\n\t\t\tknn.train(someElements)\n\t\t\tconsole.log('Finding clusters for images consisting of 5 and 9')\n\t\t\tvar res = knn.clusters(2);\n\t\t\t//console.log('Writing images...');\n\t\t\tdone();\n\t\t\t//writer.exportGrouped(res, someElements, done, \"fiveNine\")\n\t\t});\n\n\t\tit('finds centroids for data consisting of the characters 4 and 6 and 8', function(done){\n\t\t\tthis.timeout(10000);\n\t\t\tvar knn = new KMeans();\n\t\t\tvar someElements = mnist.fourAndSixAndEight().map(function(n){return n[0]}).slice(0,150);\n\t\t\tknn.train(someElements)\n\t\t\tconsole.log('Finding clusters for images consisting of 4 and 6 and 8')\n\t\t\tvar res = knn.clusters(3);\n\t\t\t//console.log('Writing images...');\n\t\t\tdone();\n\t\t\t//writer.exportGrouped(res, someElements, done, \"fourSixEight\")\n\t\t});\n\n\t});\n\n});\n\n/*EXTRA CREDIT: \n\n  As stated in the text of the workshop, there are two distinct clustering\n  tasks: (1) determining where a given number of clusters are located in space\n  given a particular data set and (2) determining how many clusters are located\n  in a given space, given a particular dataset.  All of the above pertains to \n  the first task.  The extra credit pertains to the second.\n\n  The basic task is to write an additional function, 'findClusters', which can \n  determine how many clusters are in a given set of data.  The tests below start\n  out with very obvious separations of clusters (i.e., two clumps of data which\n  are very, very far apart) and continue on to much more difficult separations.\n\n  The basic strategy that you'll want to follow is to use the existing 'clusters'\n  function to find the best set of 1, 2, 3... k clusters.  Each of these will \n  almost certainly have a smaller average centroid-training point distance than \n  the prior--this would be true even if the data were completely randomly\n  distributed without any structure at all.  However, if there are clusters in the \n  data, then the rate at which the average centroid-training point distance decreases\n  will drop once you've run out of clusters.\n\n  For instance, if there are two tight clusters with centers at [0,0] and [0,50],\n  then a clustering of 1 cluster will probably have an average centroid-training point\n  distance of 25 or so.  A clustering with 2 clusters might have an average distance\n  of .5--and a clustering with 3 might have an average distance of 0.45, with 4 might have\n  0.4, and so on.  The distance decreases as the number of clusters increases, but after the\n  average distance begins to decrease at a slow and steady rate then it probably\n  means you have exceeded the optimum number of clusters.\n\n  ...of course, most cases will not be nearly as clear as the above.\n*/\n\ndescribe('Testing optional k-means functionality', function(){\n\n\tdescribe('The algorithm can determine the number of clusters, not being told how many there are.', function(){\n\n\t\t/* The function 'findClusters' should take a number, which is the maximum\n\t\t   number of clusters it should search for.\n\n\t\t   It should return an array of centroids, just like 'clusters', but \n\t\t   the array should have anything from 1 to the input number\n\t\t   centroids in it, depending on the most natural way to split\n\t\t   the data.\n\n\t\t   It took me about 25 lines of code to do this, although that\n\t\t   could have probably been minimized.\n\t\t */\n\t\tit('can determine the number of clusters when there are two, very separate', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tvar typeB = randomPoints(100,[1,1],[50,0]);\n\t\t\tvar both = typeA.concat(typeB)\n\t\t\tknn.train(both);\n\t\t\tvar res = knn.findClusters(10);\n\t\t\texpect(res.length).to.equal(2);\n\t\t});\n\n\t\tit('can determine the number of clusters when there are three, pretty separate', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tvar typeB = randomPoints(100,[1,1],[5,0]);\n\t\t\tvar typeC = randomPoints(100,[1,1],[3,4]);\n\t\t\tvar all = typeA.concat(typeB.concat(typeC));\n\t\t\tknn.train(all)\n\t\t\tvar res = knn.findClusters(10);\n\t\t\texpect(res.length).to.equal(3);\n\t\t});\n\n\t\tit('can determine the number of clusters when there are four, fairly close', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tvar typeB = randomPoints(100,[1,1],[2,0]);\n\t\t\tvar typeC = randomPoints(100,[1,1],[1,1]);\n\t\t\tvar typeD = randomPoints(100,[1,1],[1,-1]);\n\t\t\tvar all = typeA.concat(typeB.concat(typeC.concat(typeD)));\n\t\t\tknn.train(all)\n\t\t\tvar res = knn.findClusters(10);\n\t\t\texpect(res.length).to.equal(4);\n\t\t});\n\n\t\tit('can determine the number of clusters when there are five, pretty close ones', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeA = randomPoints(100,[1,1],[0,0]);\n\t\t\tvar typeB = randomPoints(100,[1,1],[2,0]);\n\t\t\tvar typeC = randomPoints(100,[1,1],[0,2]);\n\t\t\tvar typeD = randomPoints(100,[1,1],[-2,0]);\n\t\t\tvar typeE = randomPoints(100,[1,1],[0,-2]);\n\t\t\tvar all = typeA.concat(typeB.concat(typeC.concat(typeD.concat(typeE))));\n\t\t\tknn.train(all)\n\t\t\tvar res = knn.findClusters(10);\n\t\t\texpect(res.length).to.equal(5);\n\t\t});\n\n\t\tit('can determine the number of clusters when there are four, very, very close ones', function(){\n\t\t\tvar knn = new KMeans();\n\t\t\tvar typeB = randomPoints(100,[1,1],[1,0]);\n\t\t\tvar typeC = randomPoints(100,[1,1],[0,1]);\n\t\t\tvar typeD = randomPoints(100,[1,1],[-1,0]);\n\t\t\tvar typeE = randomPoints(100,[1,1],[0,-1]);\n\t\t\tvar all = typeB.concat(typeC.concat(typeD.concat(typeE)));\n\t\t\tknn.train(all)\n\t\t\tvar res = knn.findClusters(10);\n\t\t\texpect(res.length).to.equal(4);\n\t\t});\n\n\t});\n\n\t/* This last section is really quite hard.\n\n\n\t   A lot of the ambiguity involved in the idea of a \"cluster\" comes in here,\n\t   as well as the problem that k-means is ill-suited to detecting certain kinds of cluster.\n\n\t   Anyhow, just do here what you did in the immediately prior section with the fake data.\n\t */\n\tdescribe('it can determine the number of clusters in the MNIST data as well', function(){\n\n\t\tit('can determine the number of clusters when there are two characters', function(done){\n\t\t\t//Fifteen second timeout...\n\t\t\tthis.timeout(15000);\n\t\t\tvar knn = new KMeans();\n\t\t\tvar someElements = mnist.zeroAndOne().map(function(n){return n[0]}).slice(0,100);\n\t\t\tknn.train(someElements);\n\t\t\tvar res = knn.findClusters(8);\n\t\t\texpect(res.length).to.equal(2);\n\t\t\twriter.exportGrouped(res, someElements, done, \"clusterCountedZeroAndOne\");\n\t\t});\n\n\t\tit('can determine the number of clusters when there are three characters', function(done){\n\t\t\t//Fifteen second timeout.  This can take a bit.\n\t\t\tthis.timeout(15000);\n\t\t\tvar knn = new KMeans();\n\t\t\tvar someElements = mnist.zeroAndOneAndFive().map(function(n){return n[0]}).slice(0,100);\n\t\t\tknn.train(someElements);\n\t\t\tvar res = knn.findClusters(8);\n\t\t\texpect(res.length).to.equal(3);\n\t\t\twriter.exportGrouped(res, someElements, done, \"clusterCountedZeroAndOneAndFive\");\n\t\t});\n\n\t});\n\n});\n\n"]}